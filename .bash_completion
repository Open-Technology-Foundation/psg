#!/usr/bin/env bash
# Bash completion for psg (Process Search with Grep)

_psg_complete() {
  local -- cur prev opts fields
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  # Available long and short options
  opts="-f --fields -v --verbose -q --quiet -c --case -e --exact -s --sort -n --no-color -r --regex -h --help --"

  # Available PS fields for -f and -s options
  fields="pcpu pmem group ppid user args comm rgroup nice pid pgid etime ruser time tty vsz rss stat"

  case "$prev" in
    -f|--fields)
      # Complete field names, handling comma-separated lists
      if [[ "$cur" == *,* ]]; then
        # User is adding another field after comma
        local prefix="${cur%,*},"
        local suffix="${cur##*,}"
        COMPREPLY=($(compgen -W "$fields" -- "$suffix"))
        # Add the prefix back to each completion
        COMPREPLY=("${COMPREPLY[@]/#/$prefix}")
      else
        # First field or single field
        COMPREPLY=($(compgen -W "$fields" -- "$cur"))
      fi
      return 0
      ;;
    -s|--sort)
      # Complete with field names for sorting
      COMPREPLY=($(compgen -W "$fields" -- "$cur"))
      return 0
      ;;
    --)
      # After --, complete with ps options (basic ones)
      COMPREPLY=($(compgen -W "-u -g -p -t -o -e -a -x" -- "$cur"))
      return 0
      ;;
  esac

  # Complete options if current word starts with dash
  if [[ "$cur" == -* ]]; then
    COMPREPLY=($(compgen -W "$opts" -- "$cur"))
    return 0
  fi

  # Complete with running process names (comm field)
  # Extract process names using ps and filter common ones
  local processes
  processes=$(ps -eo comm --no-headers 2>/dev/null | sort -u | grep -E "^[a-zA-Z0-9_-]+$" | head -50)
  COMPREPLY=($(compgen -W "$processes" -- "$cur"))
}

# Register the completion function
complete -F _psg_complete psg

#fin